/*
 * secadora_Reversible.c
 *
 * Created: 4/10/2025 2:09:03 PM
 * Author : Investigacion
 */ 

#include <avr/io.h>
#include <avr/interrupt.h>
#include "tiempo.h"
#include "driver_Display14ssegment.h"
#include "port.h"
#include "dryer.h"
#include "comunications.h"
/************************************** TODO *************************************/
/*
- Set up GPIO ---------------------- ./
- Set up timer ISR ----------------- ./
- Implement driver to handle screens with 14segments displays ................ ./
	*(perform double check using hardware because in proteus present strange behavior when display data with animations ) ---------------- ./
- Set up UART ISR ----------------- ./
- User menu(for each functionality: OPL, Kiosko, 2 monederos, 1 monedero)
     *WIP OPL ----------------------------------------------------------------------------------------------------------- ./
	 *Implement function to avoid re-write message if is the same message in function stringtoScreen -------------------  ./
	 *Implement functionality to continue with the current time and temperature when the cycle is interrupted by open door event  ------------------   ./
	
	 *TODO KIOSKO functionality -----------------------------------------------------------------------------------------  ./
	 finish how to process the message received, pending to implement CMD_STATUS ----------------------------------------  ./
	 
	 *TODO coin validator functionality
	      *Set up external interruption to count the width pulse time generated by coin acceptor  ----------------------- ./
		  *Add logic to activate operation cycles with coins ------------------------------------------------------------ ./
		  *Add token por tiempo parameter in progMode -------------------------------------------------------------------  ./
	 
	 
- Menu to setup the parameters (cycle time, temperature, "pull down" time)  --------------- ./
     *Implement functions to save data in EEPROM ------------------------------------------- ./
- Set up ADC (check the algorithm to calibrate thermistor)  ----------------------------------- ./

//hacer parametros Histeris low and high modificables -----------------------  ./
//Read temperature in pull down state ---------------------------------------  ./
//token por tiempo (implementar solo esta funcionalidad con monedas) -------------------------------------------------------- ./

********************************************************************* TODO ***************************************************
***************** Refactor*******************

- Continue add comments in code, and change magic number by define sentence
- Improve the way on call checkTime function in operationCycle, beacause when DOOR is open the program stops to check time, and this is not an expected behavior ---------- ./
- Implement a limit in time to reach, currently this variable could be increased without limit, max limit allowed = 99 ------------------------------   ./
- Remove lines to test tokens in checkTokenAccepted function in dryer.c file ---------------------------------------------------------------- ./
- Fix how to show temporal credit when one door is open ------------------------------------------------------------------------------------ ./

******************* Improve tasks************
- try to implement digital temperature sensor DS18b20 with the same hardware(Rev1.0)
- Implement driver to handle screens with 7segments displays
- Error alarm!

*******************************************************************************************************************************
*/

#define FOSC										16000000										//Oscillator clock frequency
#define BAUDRATE									9600


#define DIP_OPCION1								(!((readReg_OPCION1) & (1 << pin_OPCION1)))			//conected to pull ups, ON = logic 1, Off = logic 0
#define DIP_OPCION2								(!((readReg_OPCION2) & (1 << pin_OPCION2)))			//conected to pull ups, ON = logic 1, Off = logic 0
#define DELAY_OPMODE_MESSAGE					2500


typedef void(*FP)(void);
const char message1[] = " ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789 ";
const char mode_messages[][MAX_LENGH_NO_ANIMATION_MESSAGE] =
{
	"OPL",
	"KISK",
	"2MON",
	"1MON"
};
//const char message2[] = " Equipos Mautra ";
void ports_Ini();
void timer_Ini();
void uart_Ini(uint32_t fosc, uint32_t baudRate);
void ADC_Ini(void);
void external_Interrups_Ini(void);
uint8_t modeSelector(void);

//ISR(TIMER0_COMP_vect);
//ISR(USART_RXC_vect); 
//ISR(INT0_vect);
//ISR(INT1_vect);


/* brief  Config Timer0
 * 
 * Function to initialize Timer0 in CTC mode
 * to perform an interrupt each 1ms
 *
 *	param 
 *  return
 */
void timer_Ini(void)
{
    TCCR0 = 0;
    TIMSK &= ~(1<<OCIE0);

    // CTC, prescaler 256
    TCCR0 |= (1<<WGM01) | (1<<CS02);
    OCR0  = 62;   // ~1 ms @ 16 MHz
    TCNT0 = 0;

    TIMSK |= (1<<OCIE0);
}



int main(void)
{
	FP DRYMachine[] = {OPL,kiosko,coinAcceptors2,coinAcceptors1};
	
	ports_Ini();
	timer_Ini();
	iniScreen(&writeReg_MR_DISPLAY, pin_MR_DISPLAY, &writeReg_LATCH_DISPLAY, pin_LATCH_DISPLAY, &writeReg_SER_DAT_DISPLAY, pin_SER_DAT_DISPLAY, &writeReg_SRCLK_DISPLAY, pin_SRCLK_DISPLAY, NUMBER_OF_SCREENS);
	uart_Ini(FOSC, BAUDRATE);
	ADC_Ini();
	ini_VirtualTimers();
	sei();
	dryer_Ini();
	uint8_t function_Mode = modeSelector();
	
	
    while (1) 
    {
		DRYMachine[function_Mode]();
		asm("nop");
    }
}

void ports_Ini()
{
	/*Outputs*/
	configReg_CTRL_BUZZER1			|= (1 << pin_CTRL_BUZZER1);
	configReg_CTRL_IGNITOR1			|= (1 << pin_CTRL_IGNITOR1);
	configReg_CTRL_MOTORDER1		|= (1 << pin_CTRL_MOTORDER1);
	configReg_CTRL_MOTORIZQ1		|= (1 << pin_CTRL_MOTORIZQ1);
	configReg_CTRL_VENTILADOR1		|= (1 << pin_CTRL_VENTILADOR1);
	configReg_CTRL_VENTILADOR2		|= (1 << pin_CTRL_VENTILADOR2);
	configReg_CTRL_MOTORIZQ2		|= (1 << pin_CTRL_MOTORIZQ2);
	configReg_CTRL_MOTORDER2		|= (1 << pin_CTRL_MOTORDER2);
	configReg_CTRL_IGNITOR2			|= (1 << pin_CTRL_IGNITOR2);
	configReg_CTRL_BUZZER2			|= (1 << pin_CTRL_BUZZER2);
	
	configReg_MR_DISPLAY			|= (1 << pin_MR_DISPLAY);
	configReg_LATCH_DISPLAY			|= (1 << pin_LATCH_DISPLAY);
	configReg_SER_DAT_DISPLAY		|= (1 << pin_SER_DAT_DISPLAY);
	configReg_SRCLK_DISPLAY			|= (1 << pin_SRCLK_DISPLAY);

	/*Inputs*/
	configReg_PULSOMON1				&= ~(1 << pin_PULSOMON1);
	configReg_PULSOMON2				&= ~(1 << pin_PULSOMON2);
	configReg_OPCION1				&= ~(1 << pin_OPCION1);		 		
	configReg_OPCION2				&= ~(1 << pin_OPCION2);		 		
	//configReg_DOOR1					&= ~(1 << pin_DOOR1);		 		
	//configReg_DOOR2					&= ~(1 << pin_DOOR2);		 		
	configReg_BTN_IZQ_P1			&= ~(1 << pin_BTN_IZQ_P1);				
	configReg_BTN_CEN_P1			&= ~(1 << pin_BTN_CEN_P1);				
	configReg_BTN_DER_P1			&= ~(1 << pin_BTN_DER_P1);				
	configReg_BTN_IZQ_P2			&= ~(1 << pin_BTN_IZQ_P2);				
	configReg_BTN_CEN_P2			&= ~(1 << pin_BTN_CEN_P2);				
	configReg_BTN_DER_P2			&= ~(1 << pin_BTN_DER_P2);	
	configReg_THERMISTOR1			&= ~(1 << pin_THERMISTOR1);
	configReg_THERMISTOR2			&= ~(1 << pin_THERMISTOR2);
	
	/*Enable pull ups*/		
	 writeReg_OPCION1				|= (1 << pin_OPCION1);			 				
	 writeReg_OPCION2				|= (1 << pin_OPCION2);			 				
	 writeReg_BTN_IZQ_P1			|= (1 << pin_BTN_IZQ_P1);			 				
	 writeReg_BTN_CEN_P1			|= (1 << pin_BTN_CEN_P1);			 				
	 writeReg_BTN_DER_P1			|= (1 << pin_BTN_DER_P1);			 				
	 writeReg_BTN_IZQ_P2			|= (1 << pin_BTN_IZQ_P2);			 				
	 writeReg_BTN_CEN_P2			|= (1 << pin_BTN_CEN_P2);			 				
	 writeReg_BTN_DER_P2	 		|= (1 << pin_BTN_DER_P2);		
	
}



/* brief  Config UART
 * 
 * Function to initialize UART 1bit start, 1 bit stop, 8 bits data, no parity
 *
 *	param: fosc:oscilator frecuency in Hz, baudrate: bits per second
 *  return
 */
void uart_Ini(uint32_t fosc, uint32_t baudRate)
{
	uint16_t ubrr = 0;
	ubrr = (uint16_t)((fosc/(16 * baudRate)) -1 );
	
	/*Setup baudrate*/
	UBRRH = (uint8_t)(ubrr >> 8);
	UBRRL = (uint8_t)ubrr;
	
	//Enable interrupt in Rx, Enable reception Rx and transmission Tx
	UCSRB |= (1 << RXCIE) | (1 << RXEN) | (1 << TXEN);

}

/* brief  Config External Interruptions
 * 
 * Function to initialize External interruptions used in coin acceptors mode,
 * external interruptions are used to handled the pulse sent by coin acceptors when coin is introduced
 *
 *
 *	param
 *  return
 */
void external_Interrups_Ini(void)
{
	//Any logical change in INT0 and INT1 generates an interurpt request
	MCUCR |= (1 << ISC10) | (1 << ISC00);
	//Enable interrupts
	GICR |= (1 << INT1) | (1 << INT0);
}

/* brief  10bit ADC resolution
 * 4.88mv per count
 *
 * Function to initialize ADC in single conversion mode Preescaler by 128
 *  
 *	param 
 *  return
 */
void ADC_Ini(void)
{
	
	/*
	*	AVCC reference
	*   thermistor 1 channel selected
	*/
	ADMUX |= (1 << REFS0);
	THERMISTOR1_CH_ON;
		/*
	*	enable ADC
	*   ADC Start conversion  
	*	configures in single conversion mode
	*	Prescaler by 128
	*/
	ADCSRA |= (1 << ADEN) | (1 << ADSC) | (1 <<ADPS0) | (1 <<ADPS1) | (1 <<ADPS2);

}

/* brief  Return mode selector according with dip switch
 * 
 * This function returns the operation mode selected
 *
 *	param
 *  return: OPL_mode, KIOSKO_mode, MONEDEROS2_mode and MONEDEROS1_mode
 */
uint8_t modeSelector(void)
{
    
	uint8_t op_Mode = 0;
	op_Mode = get_OpMode();
	
	//if ((DIP_OPCION1 == SWITCH_OFF ) && (DIP_OPCION2 == SWITCH_OFF ))
	if (op_Mode == OPL_mode)
	{
		//OPL
		string_to_Screen(mode_messages[OPL_mode],BLINK,SCREEN1);
		string_to_Screen(mode_messages[OPL_mode],BLINK,SCREEN2);
		tiempo_Retardo(DELAY_OPMODE_MESSAGE);
		DISABLE_RX_INTERRUP;
	}
	//else if ((DIP_OPCION1 == SWITCH_OFF ) && (DIP_OPCION2 == SWITCH_ON ))
	else if (op_Mode == KIOSKO_mode)
	{
		//KIOSKO
		string_to_Screen(mode_messages[KIOSKO_mode],BLINK,SCREEN1);
		string_to_Screen(mode_messages[KIOSKO_mode],BLINK,SCREEN2);
		tiempo_Retardo(DELAY_OPMODE_MESSAGE);
	}
	//else if ((DIP_OPCION1 == SWITCH_ON ) && (DIP_OPCION2 == SWITCH_OFF ))
	else if (op_Mode == MONEDEROS2_mode)
	{
		//2 Coin acceptors
		string_to_Screen(mode_messages[MONEDEROS2_mode],BLINK,SCREEN1);
		string_to_Screen(mode_messages[MONEDEROS2_mode],BLINK,SCREEN2);
		tiempo_Retardo(DELAY_OPMODE_MESSAGE);
		external_Interrups_Ini();
		DISABLE_RX_INTERRUP;
	} 
	//else if ((DIP_OPCION1 == SWITCH_ON ) && (DIP_OPCION2 == SWITCH_ON ))
	else if (op_Mode == MONEDEROS1_mode)
	{
		//1 Monedero, 2 canastas y 2 pantallas
		string_to_Screen(mode_messages[MONEDEROS1_mode],BLINK,SCREEN1);
		string_to_Screen(mode_messages[MONEDEROS1_mode],BLINK,SCREEN2);
		tiempo_Retardo(DELAY_OPMODE_MESSAGE);
		external_Interrups_Ini();
		DISABLE_RX_INTERRUP;
		DISABLE_INT1_INTERRUP;
	} 
	
	return op_Mode;
}

/* brief  Interrupt service routine
 * 
 * This interruption is attended each 1ms
 *
 */
ISR(TIMER0_COMP_vect)
{
	static uint8_t counter = 0;;
	virutalTimers_Inc();
	if (counter == 2)
	{
		updateScreen(SCREEN1);
	}
	else if(counter == 4)
	{
		updateScreen(SCREEN2);
		counter = 0;
	}
	
	//Dryer in waiting to be activated, reset timer to avoid increase time
	if (!(dryer[CANASTA1].cycle))
	{
		
		reset_VirtualTimer(dryer[CANASTA1].timer);
	}
	if (!(dryer[CANASTA2].cycle))
	{	
		reset_VirtualTimer(dryer[CANASTA2].timer);
	}
	
	/*
	if (counter == REFRES_TIME)
	{
		sendDato(updateScreen(),(sizeof(DISPLAY_AND_LEDS_74595)/sizeof(uint8_t)), &writeReg_MR_DISPLAY_LEDS_74595, pin_MR_DISPLAY_LEDS_74595, &writeReg_LATCH_DISPLAY_LEDS_74595, pin_LATCH_DISPLAY_LEDS_74595, &writeReg_SERDAT_DISPLAY_LEDS_74595, pin_SERDAT_DISPLAY_LEDS_74595, &writeReg_SERCLK_DISPLAY_LEDS_74595, pin_SERCLK_DISPLAY_LEDS_74595);
		counter = 0;
	} */
	counter++;
}

/* brief  Interrupt service routine
 * 
 * This interruption is attended when UART receive data
 *
 */
ISR(USART_RXC_vect)
{
	uint8_t rx_value;
	asm("nop");
	rx_value = UDR;
	if ( ProcessByte_UART(rx_value) )
	{
		//message received
		dryer[CANASTA1].messageReceived_Flag = 1;
		dryer[CANASTA2].messageReceived_Flag = 1;
	}
	
	asm("nop");
	
}

/* brief  Interrupt service routine
 * 
 *  This interruption is performed when any logical change occurs in INT0
 *
 */
ISR(INT0_vect)
{
	check_TokenAccepted(CANASTA1);
}

/* brief  Interrupt service routine
 * 
 *  This interruption is performed when any logical change occurs in INT1
 *
 */
ISR(INT1_vect)
{
	check_TokenAccepted(CANASTA2);
}